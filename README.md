# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Решение

Мыслей по решению было много. Изначально было непонятно через что решать и как. Хотелось найти способ сообзить всем ждущим горутинам, что можно продолжать работу после внесения/чтения данных

### Мои варианты решения:

1) Каналы

Думал их использовать, но быстро понял, что они блокирующие и только одна горутина может одновременно читать данные

2) Очередь

Была мысль чистить каналы по завершению какого-то времени или события. Для этого удобно было бы использовать очередь, но подумав, понял, что чистить их вообще непонятно как. Т.к. мы не знаем сколько горутин осталось и какая появится в будущем. А вдруг вызовется флуд-контроль на очень большое время (N секунд, где N очень большое). Так что чистить очередь и в последующем буффер я отказался

3) Мапа

Мапа с ключами userId и значениями - массив со временами вызова функции Check. На этом варианте и остановился

### Подробнее про работу мапы:

В Check поступает userId

1) В мапу добавляем по ключу userId в массив времени текущее время. Эту операцию делаем под мьютексом, т.к. изменяется сама мапа и чтобы не мешали другие горутины. На выходе получаем данный массив с  временами(это очень важно, что мы возвращаем этот массив) 

2) Полученный массив сортируем по возрастанию 

3) Используем бинарный поиск для нахождения позиции времени в массиве, начиная с которого мы смотрим сколько раз вызывалась функция

4) Сравниваем с максимальным числом вызовов и возвращаем результат

Почему в 2) важно возвращать массив, мы же можем потом его достать из мапы? Потому что при чтении с мапы пришлось бы снова использовать мьютекс и ставить заглушку на мапу, а так мы сортируем и используем бин. поиск уже в отдельном массиве, никак не связаном с мапой и уменьшаем время работы программы и ожидания горутин

Ну и в конце чекера смотрим на контекст, на его время и если уложились - возвращаем результат, иначе - error

### Тесты

Для удобства написаны тесты в `flood_test.go`

### main.go

В нем приведен базовый пример работы с флуд-контролем

### Замечание

После долгого размышления над пунктами 1) и 2) про очередь и каналы я решил поизучать в интернете похожи варианты и вдохновился идей реализации `go-cache` по ссылке `https://github.com/patrickmn/go-cache`